# Gcc内联汇编

> 内联汇编有着不同于C语言的有趣语法，非常值得专门去学习。

[知乎好文章](https://zhuanlan.zhihu.com/p/395130640)


**%的使用**：
在汇编语句中，数字加前缀 %，如 %0、%1 等，表示需要使用寄存器的样板操作数。可以使用的此类操作数的总数取决于 CPU 中通用寄存器的数量。由于这些样板操作数也是用%前缀，因此，在涉及到具体的寄存器时就要在寄存器前面加上2个%，以免混淆。

## 内联汇编格式

### Output
格式："约束"(c 变量名)

上面的引号和圆括号都是必须的，不是文章中的特殊标识。上面的意思就是说汇编指令的结果按照某种约束/方式传给 c 变量。具体的约束形式后面详述。

变量名可能有多个，则用下面的形式："约束1"(c 变量1), "约束2"(c 变量2) ...

### Input
格式："约束"(c 变量名)

意为某 c 中的数据按照某种约束输入给汇编使用，一般就是将某 c 变量传给某个寄存器。有关多个变量的情况写法同 Output，具体的约束也后面详述。

另外内联汇编的用法挺多，上面所写的格式可能不太准确但也没什么错，因为最主要的用法就是使用约束将 c 中的变量和寄存器联系起来。

### Clobber/Modify
指定此项会通知编译器可能会破坏寄存器/内存里面的数据，然后编译器就会将这些可能被破坏的内存和寄存器提前保护起来。

若改变了寄存器 ebx 就可以申明 "bx"，bl，ebx 都行，都代表的是一个寄存器，其他的寄存器同样如此申明
若改变了 eflags 寄存器，可以申明 "cc"
若改变了内存，可以申明 "memory"
一般的，如果在 Output 和 Input 部分指定了寄存器约束，那么编译器一定知道该寄存器被改变了，那么就不用申明。