# 多处理器架构


[CSDN博客](https://blog.csdn.net/breakout_alex/article/details/110356489)
## SMP架构


SMP （Symmetric Multi-processing） , 对称多处理器结构，是相对非对称多处理技术而言的、应用十分广泛的并行技术。
*SMP并非是一种多核技术而是一种多处理器技术。*


顾名思义, 在SMP中所有的处理器都是对等的, 它们通过总线连接共享同一块物理内存，这也就导致了系统中所有资源(CPU、内存、I/O等)都是共享的，当我们打开服务器的背板盖，如果发现有多个cpu的槽位，但是却连接到同一个内存插槽的位置，那一般就是smp架构的服务器，一般pc、笔记本、手机还有一些老的服务器都是这个架构，可以发现一个特点就是cpu个数比较少，后面会阐述具体原因。

所谓对称多处理器结构，是指服务器中多个 CPU 对称工作，无主次或从属关系。各 CPU 共享相同的物理内存，每个 CPU 访问内存中的任何地址所需时间是相同的，因此 SMP 也被称为一致存储器访问结构 (UMA ：Uniform Memory Access) 。对 SMP 服务器进行扩展的方式包括增加内存、使用更快的 CPU 、增加 CPU 、扩充 I/O( 槽口数与总线数 ) 以及添加更多的外部设备 ( 通常是磁盘存储 ) 。


SMP 服务器的主要特征是共享，系统中所有资源 (CPU 、内存、 I/O 等 ) 都是共享的。也正是由于这种特征，导致了 SMP 服务器的主要问题，那就是它的扩展能力非常有限。对于 SMP 服务器而言，每一个共享的环节都可能造成 SMP 服务器扩展时的瓶颈，而最受限制的则是内存。**由于每个 CPU 必须通过相同的内存总线访问相同的内存资源，因此随着 CPU 数量的增加，内存访问冲突将迅速增加，最终会造成 CPU 资源的浪费，使 CPU 性能的有效性大大降低。** 一些博客上关于cpu个数和利用率方面有相关说明：实验证明， SMP 服务器 CPU 利用率最好的情况是 2 至 4 个 CPU。


> 6.828 Lab4中所采用SMP架构就是所有的处理器可以访问相同的地址空间。

### SMP架构如何启动计算机

SMP架构的计算机的启动方法与单核计算机的启动方法有很大的不同。


显然， 多个CPU不可能同时启动， 必定有先后次序之分， 因为我们不能让两个CPU同时执行BIOS（或EFI）里面的指令（BIOS不支持多线程） 。 因此， 除一个CPU外， 必须让其他CPU均处于中断屏蔽状态。 也就是说CPU的启动是有次序的。
问题是， 这个次序是固定的还是随机的？
对于对称多处理器结构来说， 这个顺序是固定的。 所有的CPU里面有一个被定为启动处理器（BootstrapProcessor, BSP） ， 而其他的处理器则作为应用处理器（Application Processor, AP） 。 到底哪个CPU是BSP则由某一特定寄存器的值来决定。 例如， 对于英特尔公司的多处理器结构来说， 寄存器IA32＿APIC＿BASE＿MSR里面有一个BSP标志位。 该位被设置则意味着该处理器是BSP处理器。 而在任何时候只能有一个CPU的BSP标志位被设置。 这一点可由系统总线裁决（arbitration on the system bus） 来实现。
有了BSP和AP的区别后， SMP的启动过程就比较清楚了：




1） BSP首先读取并执行BIOS（或EFI） 的初始化（boot-strap） 代码（通常处于物理地址FFFF FFF0H） 对自己进行初始化， 这种初始化包括设置APIC（Ad-vanced Programmable Interrupt Controllers， 高级可编程中断控制器） 环境， 建立全局的数据结构， 设置跳转代码（trampoline codes） 并准备AP的运行环境。
2） 而AP则在上电或重启后进行一个简单的自我设置后进入等待启动状态。
3） 然后BSP通过发送进程间中断来叫醒AP， 对AP进行启动并令其进行初始化。
4） AP在收到BSP发出的IPI启动信号后， 则将执行BIOS（或EFI） 里面的AP初始化代码或BSP准备的跳转代码。 该跳转代码将初始化AP处理器。 此后， AP再次进入等待BSP中断的状态。
5） 而BSP则继续执行BIOS或EFI的后续代码， 并负责启动操作系统。

> Intel多处理规范的核心就是高级可编程中断控制器(Advanced Programmable Interrupt Controllers--APICs)的使用。CPU通过彼此发送中断来完成它们之间的通信。通过给中断附加动作(actions)，不同的CPU可以在某种程度上彼此进行控制。每个CPU有自己的APIC(成为那个CPU的本地APIC)，并且还有一个I/O APIC来处理由I/O设备引起的中断，这个I/O APIC是安装在主板上的，但每个CPU上的APIC则不可或缺，否则将无法处理多CPU之间的中断协调。

值得一提的是， SMP的BIOS与单核或单处理器里的BIOS并不一样。 由于有多个处理器， SMP的BIOS里面包括了多个处理器的规格和信息， 每个处理器的APIC描述表。 而这些信息包括诸如CPU的数量与编号、 本地APIC信息、 I/O的APIC信息等。 由上面的启动过程也可以看出， SMP的BIOS里面不只有BSP的初始化代码，通常还包括AP的初始化代码。

### 多处理器之间的通信
在多CPU之间通信， 自然也可以发送信号。 不过这个信号不是内存的一个对象， 因为这样的话， 无法及时引起另外一个CPU的注意。 而要引起其注意， 需要发送的是中断。
用来协调这些CPU之间中断的机制就是高级可编程中断控制器（APIC） 。 这是实现SMP功能必不可少的，且是英特尔多处理规范的核心。 在此种规范下， 每个CPU内部必须内置APIC单元（成为那个CPU的本地APIC） 。 CPU通过彼此发送中断（IPI， 即处理器间中断） 来完成它们之间的通信。 通过给中断附加动作，不同的CPU可以在某种程度上彼此进行控制。
除了每个CPU自己本地的APIC外， 所有CPU通常还共享一个I/O APIC来处理由I/O设备引起的中断， 这个I/OAPIC是安装在主板上的。它们会收集来自I/O装置的中断信号且在当那些装置需要中断时传送信息至本机APIC。 每个I/O APIC有一个专有的中断输入（或IRQ） 号码。英特尔过去与目前的I/O APIC通常有24个输入， 其他的可能有多达64个。 而且有些机器拥有数个I/O APIC，每一个都有自己的输入号码， 加起来一台机器上会有上百个IRQ可供中断使用。
当然， 除了处理处理器间及输入输出的中断外， APIC也负责处理本地中断源发出的中断， 如本地连接的I/O设备、 时序中断、 性能监视计数器中断、 高温中断、 内部错误中断等。

### SMP缓存一致性
由于在对称多处理器结构下， 每个处理器都有自己的缓存， 因此在一个系统里面存在多个缓存的情况下就有可能出现两个缓存的数据不一致的情况。 即两个CPU缓存同样的数据， 其中一个或两个CPU对数据进行了修改从而造成两个CPU缓存数据的不同。 而这有可能造成严重的后果。 因此确保SMP里面的缓存一致性十分重要。
SMP必须确保对内存地址的访问是最新的数据。 为此， 必须使用一些特定的缓存一致性策略或模型。 而缓存一致性策略在学术界得到了广泛的研究， 并存在许多现成的模型或方法。 例如， 英特尔公司的x86体系结构使用MESI模型来实现缓存的一致性。 MESI是英语4个单词的首字母缩写： Modified、 Exclusive、Shared、 Invalid。 这4个字母分别代表缓存的4个状态： 修改、 独享、 共享和无效。



